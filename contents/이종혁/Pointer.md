# 포인터 
> 메모리 주소를 저장하는 변수로 특정 주소의 데이터에 접근할 수 있다

 * 포인터 선언: [TYPE * 변수이름]
 * ex) int * ptr;

***포인터의 크기는 4 or 8바이트 고정 크기이다***
 
<br>

``` cpp
#include<iostream>

using namespace std;

// 얕은 복사
// hp의 값을 복사해서 가져오기 때문에
// main 함수의 지역변수 hp의 값이 바뀌지 않는다
// void  SetHP(int hp)
// {
//     hp = 100;
// }

// 깊은 복사
// hp의 주소 값을 매개변수로 가져와
// 해당 주소에 직접 접근하여 데이터를 수정하기 때문에
// main 함수의 지역변수 hp의 값이 바뀐다
void  SetHP(int * hp)
{
    * hp = 100;
}


int main(int argc, char * argv[])
{
    int hp = 1;
    // SetHP(hp);
    SetHP(&hp); 
    return 0;
}
```

<br>

## 포인터 연산


### 1. 주소 연산자 `&`
> 주소 연산자 `&`를 사용하면 변수에 할당된 메모리 주소를 확인할 수 있다

 * 해당 변수 타입(TYPE)에 따라서 TYPE * 를 반환해준다.

<br>

### 2. 산술 연산자 `+, -`
> 포인터에도 사용이 가능하다

``` cpp
int num = 1;
int * ptr = & num;

num ++;      // 변수 num이 1 증가

ptr ++;      // num의 주소에서 int(4바이트) 크기 만큼 가리키는 주소 값이 증가
```

> 포인터에서 산술 연산은 해당 TYPE의 크기 만큼 연산한다.

<br>

### 3. 간접 연산자 `*`
> 간접 연산자 `*`를 사용하면 특정 주소의 데이터에 접근할 수 있다

<br>

### 4. 간접 멤버 연산자 `->`
> 간접 연산자 `*`와 구조체의 특정 멤버를 다룰 때 사용하는 `.` 을 합친 것

 * (*Player).hp = Player->hp 
---

<br>

## 참조 (reference)
> 변수의 주소를 받아와 또 다른 이름을 부여한 것 

### 일반 변수
> 값을 저장하기 위해 메모리에 공간을 할당받아 직접 저장하는 변수

<br>

### 포인터 변수
> 다른 변수의 주소 값을 저장하는 변수

<br>

### 참조 변수
> 한 객체가 다른 객체를 연결하는 수단
> * 다른 객체나 값에 대한 별명으로 사용
> * 크기가 큰 객체를 함수에 인수로 전달할 때 주로 사용한다

 * [TYPE & 변수명] 으로 사용한다

***로우레벨(어셈블리) 관점에서 실제 작동 방식은 포인터와 동일하다***

<br>

### 특징
1. 참조 변수는 선언과 동시에 초기화해야 한다
2. null 값을 저장할 수 있는 포인터와 다르게 null을 참조할 수 없다
3. 참조하려는 변수와의 데이터 타입을 일치시켜야 한다
4. 한번 참조한 변수는 재참조가 불가능하다

<br>

### ***값 전달처럼 편리하고 포인터처럼 주소에 저장된 실제 값을 참조할 수 있는 방식이다***
---

<br>

## 포인터 VS 참조

<br>

### 1. 편의성
> 성능은 똑같지만 편의성 면에서는 참조가 더 좋다

<br>

### ***하지만 편의성이 좋다는게 꼭 장점만은 아니다***
> 포인터를 주소를 넘기니 확실하게 원본을 넘긴다는 힌트를 줄 수 있는 반면 참조는 자연스럽게 모르고 지나칠 수도 있다

<br>

### 예시
``` cpp
Print(int * a);    // 포인터

Print(const int & a);    // 참조 형식으로 값을 수정하지 못하게 const 형식으로 받아오는 것이 좋다 

int main()
{
    int a = 10;

    Print(&a);   // 포인터 형식으로 주소 값을 참조한다는 것을 한눈에 알아보기 쉽다

    Print(a);    // 참조 형식으로 주소 값을 참조한다는 것을 한눈에 알아보기 힘들다
}
```

<br>

### ***const를 어디에 써야할까 ?***
``` cpp
const int * num     // `참조해 온 데이터`를 상수화
int * const num     // `참조한 주소 값`을 상수화
```


<br>

### 2. 초기화

참조
> 참조는 대상의 별칭 느낌으로 참조하는 대상이 없으면 안된다
> * 선언과 동시에 초기화해야 한다 

포인터
> 포인터는 그냥 어떤~ 주소라는 의미로 대상이 실존하지 않을 수도 있다
> * 포인터에서 존재하지 않다 = `nullptr` 이다

<br>

### 정리
 * 없는 경우도 고려해야 한다면 포인터(null 체크 필수)
 * 바뀌지 않고 읽는 용도(readonly)만 사용한다면 const ref& 
 * 그 외 일반적으로 ref (명시적으로 호출할 때 OUT 사용)
 * 포인터와 참조를 섞어서 사용하는 것을 주의하자 ! 

<br>

``` cpp
#define OUT

ChangeInfo(OUT int & num);   // 수정 될 수 있음을 명시적으로 표시
```




