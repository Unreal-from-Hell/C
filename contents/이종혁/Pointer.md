# 포인터 
> 메모리 주소를 저장하는 변수로 특정 주소의 데이터에 접근할 수 있다

 * 포인터 선언: [TYPE * 변수이름]
 * ex) int * ptr;

***포인터의 크기는 4 or 8바이트 고정 크기이다***
 
<br>

``` cpp
#include<iostream>

using namespace std;

// 얕은 복사
// hp의 값을 복사해서 가져오기 때문에
// main 함수의 지역변수 hp의 값이 바뀌지 않는다
// void  SetHP(int hp)
// {
//     hp = 100;
// }

// 깊은 복사
// hp의 주소 값을 매개변수로 가져와
// 해당 주소에 직접 접근하여 데이터를 수정하기 때문에
// main 함수의 지역변수 hp의 값이 바뀐다
void  SetHP(int * hp)
{
    * hp = 100;
}


int main(int argc, char * argv[])
{
    int hp = 1;
    // SetHP(hp);
    SetHP(&hp); 
    return 0;
}
```

<br>

## 포인터 연산


### 1. 주소 연산자 `&`
> 주소 연산자 `&`를 사용하면 변수에 할당된 메모리 주소를 확인할 수 있다

 * 해당 변수 타입(TYPE)에 따라서 TYPE * 를 반환해준다.

<br>

### 2. 산술 연산자 `+, -`
> 포인터에도 사용이 가능하다

``` cpp
int num = 1;
int * ptr = & num;

num ++;      // 변수 num이 1 증가

ptr ++;      // num의 주소에서 int(4바이트) 크기 만큼 가리키는 주소 값이 증가
```

> 포인터에서 산술 연산은 해당 TYPE의 크기 만큼 연산한다.

<br>

### 3. 간접 연산자 `*`
> 간접 연산자 `*`를 사용하면 특정 주소의 데이터에 접근할 수 있다

<br>

### 4. 간접 멤버 연산자 `->`
> 간접 연산자 `*`와 구조체의 특정 멤버를 다룰 때 사용하는 `.` 을 합친 것

 * (*Player).hp = Player->hp 

<br>





